<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>Javascript模块化 · 长剑腥腥挂壁</title><meta name="description" content="随着其规模化和复杂度的成倍增长，其软件工程体系也随之建立起来（协同开发、单元测试、需求和缺陷管理等），模块化编程的需求日益迫切。模块化编程就是通过组合一些相对独立可复用的模块来进行功能的实现，其最核心的两部分是定义模块和引入模块；

定义模块时，每个模块内部的执行逻辑是不被外部感知的，只是导出（暴露"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Javascript模块化</a></h3></div><div class="post-content"><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">随着其规模化和复杂度的成倍增长，其软件工程体系也随之建立起来（协同开发、单元测试、需求和缺陷管理等），模块化编程的需求日益迫切。</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">模块化编程就是通过组合一些相对独立可复用的模块来进行功能的实现，其最核心的两部分是定义模块和引入模块；</span></span></p>
<ul>
<li>定义模块时，每个模块内部的执行逻辑是不被外部感知的，只是导出（暴露）出部分方法和数据；</li>
<li>引入模块时，同步 / 异步去加载待引入的代码，执行并获取到其暴露的方法和数据dao</li>
</ul>
<h1 id="刀耕火种"><a href="#刀耕火种" class="headerlink" title="刀耕火种"></a>刀耕火种</h1><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">尽管 JavaScript 语言层面并未提供模块化的解决方案，但利用其可面向对象的语言特性，外加设计模式加持，能够实现一些简单的模块化的架构；经典的一个案例是利用单例模式模式去实现模块化，可以对模块进行较好的封装，只暴露部分信息给需要使用模块的地方；</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a module</span></span><br><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span> (<span class="params">$, doc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> methodA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> dataA = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    methodA: methodA,</span><br><span class="line">    dataA: dataA</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(jQuery, <span class="built_in">document</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a module</span></span><br><span class="line"><span class="keyword">var</span> result = moduleA.mehodA();</span><br></pre></td></tr></table></figure></p>
<p>直观来看，通过立即执行函数（IIFE）来声明依赖以及导出数据，这与当下的模块化方案并无巨大的差异，可本质上却有千差万别，无法满足的一些重要的特性；</p>
<ul>
<li>定义模块时，声明的依赖不是强制自动引入的，即在定义该模块之前，必须手动引入依赖的模块代码；</li>
<li>定义模块时，其代码就已经完成执行过程，无法实现按需加载；</li>
<li>跨文件使用模块时，需要将模块挂载到全局变量（window）上；</li>
</ul>
<h1 id="AMD和CMD二分天下"><a href="#AMD和CMD二分天下" class="headerlink" title="AMD和CMD二分天下"></a>AMD和CMD二分天下</h1><p>这两种模块化方案逐渐淡出历史舞台<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">为了解决”刀耕火种”时代存留的需求，AMD 和 CMD 模块化规范问世，解决了在浏览器端的异步模块化编程的需求，其最核心的原理是通过动态加载 script 和事件监听的方式来异步加载模块；</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">AMD 和 CMD 最具代表的两个作品分别对应 require.js 和 sea.js；其主要区别在于依赖声明和依赖加载的时机，其中 require.js 默认在声明时执行， sea.js 推崇懒加载和按需使用；另外值得一提的是，CMD 规范的写法和 CommonJS 极为相近，只需稍作修改，就能在 CommonJS 中使用。</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA, moduleB</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖前置</span></span><br><span class="line">  moduleA.mehodA();</span><br><span class="line">  <span class="built_in">console</span>.log(moduleB.dataB);</span><br><span class="line">  <span class="comment">// 导出数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖就近</span></span><br><span class="line">  <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  moduleA.mehodA();     </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按需加载</span></span><br><span class="line">  <span class="keyword">if</span> (needModuleB) &#123;</span><br><span class="line">    <span class="keyword">var</span> moduleB = requie(<span class="string">'./b'</span>);</span><br><span class="line">    moduleB.methodB();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 导出数据</span></span><br><span class="line">  exports = &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">2009 年 ty 发布 Node.js 的第一个版本，CommonJS 作为其中最核心的特性之一，适用于服务端下的场景；历年来的考察和时间的洗礼，以及前端工程化对其的充分支持，CommonJS 被广泛运用于 Node.js 和浏览器；</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Core Module</span></span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="comment">// Npm Module</span></span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"><span class="comment">// Custom Module</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">'./foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; axios &#125;;</span><br><span class="line">exports.foo = foo;</span><br></pre></td></tr></table></figure></p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul>
<li>module (Object): 模块本身</li>
<li>exports (*): 模块的导出部分，即暴露出来的内容</li>
<li>require (Function): 加载模块的函数，获得目标模块的导出值（基础类型为复制，引用类型为浅拷贝），可以加载内置模块、npm 模块和自定义模块<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3>1、模块定义<br>默认任意 .node .js .json 文件都是符合规范的模块；<br>2、引入模块<br>首先从缓存（require.cache）优先读取模块，如果未命中缓存，则进行路径分析，然后按照不同类型的模块处理：</li>
<li>内置模块，直接从内存加载；</li>
<li>外部模块，首先进行文件寻址定位，然后进行编译和执行，最终得到对应的导出值；<br>其中在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装，结果如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The area of a circle of radius 4 is '</span> + circle.area(<span class="number">4</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h3><ul>
<li>同步执行模块声明和引入逻辑，分析一些复杂的依赖引用（如循环依赖）时需注意；</li>
<li>缓存机制，性能更优，同时限制了内存占用；</li>
<li>Module 模块可供改造的灵活度高，可以实现一些定制需求（如热更新、任意文件类型模块支持）；</li>
</ul>
<h1 id="ES-Module（推荐使用）"><a href="#ES-Module（推荐使用）" class="headerlink" title="ES Module（推荐使用）"></a>ES Module（推荐使用）</h1><p>ES Module 是语言层面的模块化方案，由 ES 2015 提出，其规范与 CommonJS 比之 ，导出的值都可以看成是一个具备多个属性或者方法的对象，可以实现互相兼容；但写法上 ES Module 更简洁，与 Python 接近；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> color <span class="keyword">from</span> <span class="string">'color'</span>;</span><br><span class="line"><span class="keyword">import</span> service, &#123; getArticles &#125; <span class="keyword">from</span> <span class="string">'../service'</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getArticles = getArticles;</span><br></pre></td></tr></table></figure>
<p>主要差异在于：</p>
<ul>
<li>ES Module 会对静态代码分析，即在代码编译时进行模块的加载，在运行时之前就已经确定了依赖关系（可解决循环引用的问题）；</li>
<li>ES Module 关键字：<code>import</code> <code>export</code> 以及独有的 <code>default</code> 关键字，确定默认的导出值；</li>
<li>ES Module 中导入模块的属性或者方法是强绑定的，包括基础类型；</li>
</ul>
<h1 id="构建工具中的实现"><a href="#构建工具中的实现" class="headerlink" title="构建工具中的实现"></a>构建工具中的实现</h1><p>为了在浏览器环境中运行模块化的代码，需要借助一些模块化打包的工具进行打包（ 以 webpack 为例），定义了项目入口之后，会先快速地进行依赖的分析，然后将所有依赖的模块转换成浏览器兼容的对应模块化规范的实现；</p>
<h3 id="模块化的基础"><a href="#模块化的基础" class="headerlink" title="模块化的基础"></a>模块化的基础</h3><p>从上面的介绍中，我们已经对其规范和实现有了一定的了解；在浏览器中，要实现 CommonJS 规范，只需要实现 module / exports / require / global 这几个属性，由于浏览器中是无法访问文件系统的，因此 require 过程中的文件定位需要改造为加载对应的 JS 片段（webpack 采用的方式为通过函数传参实现依赖的引入）。具体实现可以参考：<a href="https://github.com/ruanyf/tiny-browser-require" target="_blank" rel="noopener">tiny-browser-require</a>。</p>
<p>webpack 打包出来的代码快照如下，注意看注释中的时序；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(<span class="number">0</span>); <span class="comment">// ---&gt; 0</span></span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Define module A</span></span><br><span class="line">    <span class="keyword">var</span> moduleB = __webpack_require__(<span class="number">1</span>); <span class="comment">// ---&gt; 1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Define module B</span></span><br><span class="line">    exports = &#123;&#125;; <span class="comment">// ---&gt; 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实际上，ES Module 的处理同 CommonJS 相差无几，只是在定义模块和引入模块时会去处理 __esModule 标识，从而兼容其在语法上的差异。</p>
<h3 id="异步和扩展"><a href="#异步和扩展" class="headerlink" title="异步和扩展"></a>异步和扩展</h3><p>1、浏览器环境下，网络资源受到较大的限制，因此打包出来的文件如果体积巨大，对页面性能的损耗极大，因此需要对构建的目标文件进行拆分，同时模块也需要支持动态加载；<br>webpack 提供了两个方法 require.ensure() 和 import() （推荐使用）进行模块的动态加载，至于其中的原理，跟上面提及的 AMD &amp; CMD 所见略同，import() 执行后返回一个 Promise 对象，其中所做的工作无非也是动态新增 script 标签，然后通过 onload / onerror 事件进一步处理。<br>2、由于 require 函数是完全自定义的，我们可以在模块化中实现更多的特性，比如通过修改 require.resolve 或 Module._extensions 扩展支持的文件类型，使得 css / .jsx / .vue / 图片等文件也能为模块化所使用；</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-11-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/js/" title="js">js </a><a class="tag" href="/tags/模块化/" title="模块化">模块化 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/11/14/字符串方法/" title="字符串方法">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/11/12/数组方法/" title="数组方法">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>